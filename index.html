<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pothole Reporter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .spinner { border-top-color: #3498db; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        #location-icon.loading { animation: pulse 1.5s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-md bg-white rounded-xl shadow-lg p-6 md:p-8 space-y-6">
        
        <!-- Header -->
        <div class="text-center">
            <div class="flex items-center justify-center mx-auto w-16 h-16 bg-red-100 rounded-full mb-4">
                 <svg class="w-8 h-8 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
            </div>
            <h1 class="text-2xl font-bold text-gray-900">Pothole Reporter</h1>
            <p class="text-gray-500 mt-1">Help improve our roads, one report at a time.</p>
        </div>

        <!-- Location Section -->
        <div class="bg-gray-50 p-4 rounded-lg">
            <h2 class="font-semibold text-gray-700 mb-2 flex items-center">
                <svg id="location-icon" class="w-5 h-5 mr-2 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
                Current Location
            </h2>
            <p id="location-status" class="text-sm text-gray-600">Fetching your location...</p>
            <div id="manual-location-section" class="hidden mt-2">
                 <button id="manual-location-btn" class="text-xs text-blue-600 hover:underline">Enter Address Manually</button>
            </div>
            <form id="location-form" class="hidden mt-3 space-y-2">
                <input type="text" id="address-input" placeholder="Enter street address" class="w-full text-sm border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500">
                <button type="submit" class="text-xs px-2 py-1 bg-blue-600 text-white rounded-md hover:bg-blue-700">Use this address</button>
            </form>
        </div>

        <!-- Upload & Result Section -->
        <div id="upload-section">
            <label for="file-upload" class="relative cursor-pointer w-full flex flex-col items-center justify-center h-48 bg-white border-2 border-dashed border-gray-300 rounded-lg hover:bg-gray-50 transition-colors">
                <div class="text-center">
                    <svg class="mx-auto h-12 w-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path></svg>
                    <p class="mt-2 text-sm font-medium text-blue-600">Click to upload an image</p>
                    <p class="mt-1 text-xs text-gray-500">PNG, JPG, GIF up to 10MB</p>
                </div>
            </label>
            <input id="file-upload" type="file" class="sr-only" accept="image/*">
        </div>

        <div id="result-section" class="hidden space-y-4">
            <div class="text-center">
                <h2 id="result-title" class="text-lg font-semibold text-gray-800">Analysis Complete</h2>
                <p id="result-message" class="text-sm text-gray-600"></p>
            </div>
            <img id="result-image" class="rounded-lg shadow-md max-w-full mx-auto" alt="Analysis result">
            <div id="manual-report-section" class="hidden">
                 <p class="text-sm text-center text-gray-600 mb-2">The AI couldn't find a pothole. You can still report it manually.</p>
                 <form id="manual-report-form" class="space-y-2">
                    <textarea id="manual-description" rows="3" class="w-full text-sm border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500" placeholder="Please describe the issue (e.g., 'Deep pothole near the crosswalk')"></textarea>
                    <button type="submit" class="w-full px-4 py-2 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">Submit Manual Report</button>
                 </form>
            </div>
        </div>

        <!-- Status & Spinner -->
        <div id="status-section" class="hidden flex flex-col items-center justify-center text-center space-y-3">
             <div class="spinner w-8 h-8 rounded-full border-4 border-gray-200"></div>
             <p id="status-text" class="text-sm text-gray-600 font-medium">Analyzing image...</p>
        </div>

    </div>

    <script>
        // --- DOM ELEMENT REFERENCES ---
        const uploadSection = document.getElementById('upload-section');
        const fileUpload = document.getElementById('file-upload');
        const resultSection = document.getElementById('result-section');
        const resultImage = document.getElementById('result-image');
        const resultTitle = document.getElementById('result-title');
        const resultMessage = document.getElementById('result-message');
        const statusSection = document.getElementById('status-section');
        const statusText = document.getElementById('status-text');
        const locationStatus = document.getElementById('location-status');
        const locationIcon = document.getElementById('location-icon');
        const manualLocationSection = document.getElementById('manual-location-section');
        const manualLocationBtn = document.getElementById('manual-location-btn');
        const locationForm = document.getElementById('location-form');
        const addressInput = document.getElementById('address-input');
        const manualReportSection = document.getElementById('manual-report-section');
        const manualReportForm = document.getElementById('manual-report-form');
        const manualDescriptionInput = document.getElementById('manual-description');

        // --- STATE MANAGEMENT ---
        let currentLocation = {
            latitude: null,
            longitude: null,
            address: 'Not available',
            isManual: false
        };

        // --- CONFIGURATION ---
        const ROBOFLOW_API_KEY = "djY6VSuRnjsR4C3waivR";
        const MODEL_ID = "new-pothole-detection/1";
        const ROBOFLOW_API_URL = `https://detect.roboflow.com/${MODEL_ID}?api_key=${ROBOFLOW_API_KEY}`;
        const OPENCAGE_API_KEY = '2e0018d31b4d415598d575ff48495d84';
        const EMAIL_TO = 'pranavkh2411@gmail.com';

        // --- EVENT LISTENERS ---
        document.addEventListener('DOMContentLoaded', getLocation);
        fileUpload.addEventListener('change', handleFileSelect);
        manualLocationBtn.addEventListener('click', () => {
            locationForm.classList.remove('hidden');
            manualLocationBtn.classList.add('hidden');
        });
        locationForm.addEventListener('submit', handleManualLocationSubmit);
        manualReportForm.addEventListener('submit', handleManualReportSubmit);
        
        // --- LOCATION HANDLING ---
        function getLocation() {
            if (navigator.geolocation) {
                locationIcon.classList.add('loading');
                navigator.geolocation.getCurrentPosition(showPosition, showError, { enableHighAccuracy: true });
            } else {
                setLocationStatus("Geolocation is not supported by this browser.", 'error');
            }
        }

        async function showPosition(position) {
            currentLocation.latitude = position.coords.latitude;
            currentLocation.longitude = position.coords.longitude;
            try {
                const response = await fetch(`https://api.opencagedata.com/geocode/v1/json?q=${currentLocation.latitude}+${currentLocation.longitude}&key=${OPENCAGE_API_KEY}`);
                const data = await response.json();
                if (data.results && data.results.length > 0) {
                    currentLocation.address = data.results[0].formatted;
                    setLocationStatus(currentLocation.address, 'success');
                } else {
                    throw new Error('No address found for coordinates.');
                }
            } catch (error) {
                console.error("Reverse geocoding error:", error);
                setLocationStatus(`Lat: ${currentLocation.latitude.toFixed(4)}, Lon: ${currentLocation.longitude.toFixed(4)}`, 'warning');
            }
        }

        function showError(error) {
            let message = '';
            switch (error.code) {
                case error.PERMISSION_DENIED: message = "User denied the request for Geolocation."; break;
                case error.POSITION_UNAVAILABLE: message = "Location information is unavailable."; break;
                case error.TIMEOUT: message = "The request to get user location timed out."; break;
                default: message = "An unknown error occurred."; break;
            }
            setLocationStatus(message, 'error');
        }

        function setLocationStatus(text, status = 'default') {
            locationStatus.textContent = text;
            locationIcon.classList.remove('loading', 'text-green-500', 'text-red-500', 'text-yellow-500', 'text-gray-400');
            switch (status) {
                case 'success': locationIcon.classList.add('text-green-500'); break;
                case 'error': locationIcon.classList.add('text-red-500'); break;
                case 'warning': locationIcon.classList.add('text-yellow-500'); break;
                default: locationIcon.classList.add('text-gray-400'); break;
            }
            // Always show the manual entry button after the first attempt
            manualLocationSection.classList.remove('hidden');
        }
        
        function handleManualLocationSubmit(event) {
            event.preventDefault();
            const address = addressInput.value.trim();
            if (address) {
                currentLocation.address = address;
                currentLocation.latitude = null;
                currentLocation.longitude = null;
                currentLocation.isManual = true;
                setLocationStatus(`${address} (Manual Entry)`, 'success');
                locationForm.classList.add('hidden');
            }
        }

        // --- FILE HANDLING & ANALYSIS ---
        async function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Show spinner and hide upload form
            uploadSection.classList.add('hidden');
            statusSection.classList.remove('hidden');
            resultSection.classList.add('hidden'); // Hide previous results
            manualReportSection.classList.add('hidden');

            const reader = new FileReader();
            reader.onload = async function(e) {
                // Display the uploaded image immediately
                const originalImageSrc = e.target.result;

                // For Roboflow, we need the raw base64 string without the data URL prefix
                const base64Image = originalImageSrc.split(',')[1];
                
                statusText.textContent = 'Analyzing image...';
                
                try {
                    const response = await fetch(ROBOFLOW_API_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded'
                        },
                        body: base64Image
                    });
                    const data = await response.json();
                    displayResult(data, originalImageSrc);
                } catch (error) {
                    console.error("Roboflow API error:", error);
                    displayResult({ error: "Failed to connect to the analysis service." }, originalImageSrc);
                }
            };
            reader.readAsDataURL(file);
        }

        // --- DISPLAY & REPORTING ---
        async function displayResult(data, imageSrc) {
            statusSection.classList.add('hidden');
            resultSection.classList.remove('hidden');

            if (data.error || !data.predictions || data.predictions.length === 0) {
                resultTitle.textContent = "No Potholes Detected";
                resultMessage.textContent = "Our AI analysis did not find any potholes in the image.";
                resultImage.src = imageSrc; // Show the original image
                manualReportSection.classList.remove('hidden');
                return; // Stop here if no potholes are found
            }

            // A pothole was detected
            const prediction = data.predictions[0];
            const confidence = (prediction.confidence * 100).toFixed(1);
            resultTitle.textContent = "Pothole Detected!";
            resultMessage.textContent = `A pothole was detected with ${confidence}% confidence. An automated report will be sent.`;
            
            // Draw the bounding box on the image
            const annotatedImageSrc = await drawBoundingBox(imageSrc, data.predictions);
            resultImage.src = annotatedImageSrc;

            // Send the automated report
            const emailSubject = `Pothole Report: ${currentLocation.address}`;
            const emailBody = `
                <h2>Automated Pothole Report</h2>
                <p>A pothole has been detected at the following location:</p>
                <p><strong>Address:</strong> ${currentLocation.address}</p>
                ${!currentLocation.isManual && currentLocation.latitude ?
                `<p><strong>Coordinates:</strong> ${currentLocation.latitude.toFixed(6)}, ${currentLocation.longitude.toFixed(6)}</p>
                 <p><a href="https://www.google.com/maps?q=${currentLocation.latitude},${currentLocation.longitude}" target="_blank">View on Google Maps</a></p>` : ''}
                <hr>
                <p>The AI detected this with ${confidence}% confidence.</p>
                <p>Please find the annotated image attached below.</p>
                <img src="${annotatedImageSrc}" alt="Detected pothole" style="max-width: 100%; height: auto; border: 1px solid #ccc;"/>
            `;
            sendEmailReport(emailSubject, emailBody);
        }

        async function handleManualReportSubmit(event) {
            event.preventDefault();
            const description = manualDescriptionInput.value.trim();
            if (!description) {
                alert('Please provide a description of the issue.');
                return;
            }
            
            // Use the original uploaded image for the report
            const originalImageSrc = resultImage.src; 

            const emailSubject = `MANUAL Pothole Report: ${currentLocation.address}`;
            const emailBody = `
                <h2>Manual Pothole Report</h2>
                <p>A citizen has submitted a manual report for the following location:</p>
                <p><strong>Address:</strong> ${currentLocation.address}</p>
                 ${!currentLocation.isManual && currentLocation.latitude ?
                `<p><strong>Coordinates:</strong> ${currentLocation.latitude.toFixed(6)}, ${currentLocation.longitude.toFixed(6)}</p>
                 <p><a href="https://www.google.com/maps?q=${currentLocation.latitude},${currentLocation.longitude}" target="_blank">View on Google Maps</a></p>` : ''}
                <hr>
                <h3>User's Description:</h3>
                <p><em>"${description}"</em></p>
                <hr>
                <p>The original uploaded image is attached below.</p>
                <img src="${originalImageSrc}" alt="User uploaded image" style="max-width: 100%; height: auto; border: 1px solid #ccc;"/>
            `;
            
            statusText.textContent = 'Submitting your report...';
            statusSection.classList.remove('hidden');
            manualReportSection.classList.add('hidden');

            await sendEmailReport(emailSubject, emailBody);

            resultTitle.textContent = "Manual Report Sent";
            resultMessage.textContent = "Thank you! Your manual report has been successfully submitted.";
        }

        async function sendEmailReport(subject, html) {
            try {
                // This URL points to our Vercel serverless function.
                const response = await fetch('/api/send-email', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        to: EMAIL_TO,
                        subject: subject,
                        html: html
                    })
                });

                const result = await response.json();
                if (!response.ok) {
                    throw new Error(result.message || 'Failed to send email.');
                }
                console.log('Email sent successfully:', result);
            } catch (error) {
                console.error('Email sending error:', error);
                alert(`Error: Could not send the report.\n${error.message}`);
            } finally {
                // Ensure spinner is hidden after attempt
                statusSection.classList.add('hidden');
            }
        }

        function drawBoundingBox(imageSrc, predictions) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    
                    // Style for the box and text
                    ctx.strokeStyle = '#FF0000';
                    ctx.lineWidth = Math.max(4, img.width * 0.005); // Line width scales with image size
                    ctx.fillStyle = '#FF0000';
                    ctx.font = `bold ${Math.max(16, img.width * 0.02)}px Arial`;
                    ctx.textAlign = 'center';

                    predictions.forEach(p => {
                        const x = p.x - p.width / 2;
                        const y = p.y - p.height / 2;
                        const width = p.width;
                        const height = p.height;
                        
                        // Draw the box
                        ctx.strokeRect(x, y, width, height);

                        // Draw the label background
                        const text = `${p.class} (${(p.confidence * 100).toFixed(0)}%)`;
                        const textMetrics = ctx.measureText(text);
                        const textBgHeight = textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent + 8;
                        ctx.fillRect(x, y - textBgHeight, textMetrics.width + 10, textBgHeight);

                        // Draw the text
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillText(text, x + (textMetrics.width/2) + 5, y - 4);
                        ctx.fillStyle = '#FF0000'; // Reset for next box
                    });
                    resolve(canvas.toDataURL('image/jpeg'));
                };
                img.src = imageSrc;
            });
        }
    </script>
</body>
</html>
