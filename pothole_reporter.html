<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pothole Reporter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
        }
        .app-card {
            background-color: white;
            border-radius: 1.5rem;
            box-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
            transition: all 0.3s ease-in-out;
        }
        .loader {
            border-top-color: #3b82f6;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #drop-zone {
            border: 2px dashed #d1d5db;
            transition: border-color 0.2s, background-color 0.2s;
        }
        #drop-zone.drag-over {
            border-color: #3b82f6;
            background-color: #eff6ff;
        }
        .section-transition {
            transition: opacity 0.5s ease-in-out, transform 0.5s ease-in-out, max-height 0.5s ease-in-out;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex items-center justify-center min-h-screen p-4">

    <div id="app" class="w-full max-w-md mx-auto app-card p-6 md:p-8 space-y-6">

        <!-- Header -->
        <div class="text-center">
            <div class="inline-block bg-blue-100 text-blue-600 p-3 rounded-full">
                <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-cone"><path d="M20.9 18.55a1 1 0 0 1-1.8 0l-6.24-12.48a1 1 0 0 1 1.79-.9L20.9 18.55Z"/><path d="m20.89 18.56 1.06-2.12a1 1 0 0 0-1.79-.9l-1.06 2.12"/><path d="M12.72 5.2a1 1 0 0 0-1.79-.9L3.11 18.55a1 1 0 0 0 1.79.9l2.12-1.06"/><path d="M10.89 16.44 3.11 18.55a1 1 0 0 0 1.79.9l7.78-2.11"/><path d="M14 19.5c-3.33-2-5.33-5.5-5.33-9.5 0-4 2-7.5 5.33-9.5"/></svg>
            </div>
            <h1 class="text-3xl font-extrabold text-gray-900 mt-4">Pothole Reporter</h1>
            <p class="text-gray-500 mt-1">Help make our roads safer, one photo at a time.</p>
        </div>

        <!-- Step 1: Geolocation -->
        <div id="location-section" class="bg-gray-50 p-4 rounded-xl flex flex-col items-start space-y-2">
            <div class="flex items-center space-x-3 w-full justify-between">
                <div class="flex items-center space-x-3">
                    <i id="location-icon" data-lucide="map-pin" class="text-blue-500"></i>
                    <span id="location-title" class="text-gray-700 font-medium">Fetching Address...</span>
                </div>
                <div id="location-loader" class="loader ease-linear rounded-full border-2 border-t-2 border-gray-200 h-5 w-5"></div>
            </div>
            <p id="location-status" class="text-gray-600 text-sm ml-9"></p>
            <div class="w-full text-right mt-1">
                 <button id="manual-location-toggle" class="hidden text-sm text-blue-600 hover:underline">Enter Address Manually</button>
            </div>
        </div>

        <!-- Manual Location Form -->
        <div id="manual-location-section" class="hidden space-y-2 section-transition opacity-0">
            <label for="manual-address-input" class="block text-sm font-medium text-gray-700">Enter Address:</label>
            <input type="text" id="manual-address-input" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500" placeholder="e.g., Near Albert Hall Museum, Jaipur">
            <div class="flex justify-end">
                <button id="submit-manual-location" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition-colors">Update Location</button>
            </div>
        </div>

        <!-- Step 2: Image Upload -->
        <div id="upload-section">
            <input type="file" id="image-upload-input" class="hidden" accept="image/*">
            <div id="drop-zone" class="w-full p-8 text-center rounded-xl cursor-pointer">
                <div class="flex flex-col items-center justify-center text-gray-500">
                    <i data-lucide="upload-cloud" class="w-12 h-12 mb-3"></i>
                    <p class="font-bold">Click to upload or drag & drop</p>
                    <p class="text-sm">PNG, JPG, or JPEG</p>
                </div>
            </div>
        </div>
        
        <!-- Status Display -->
        <div id="status-display" class="hidden text-center p-4 rounded-lg section-transition opacity-0">
             <div class="flex justify-center items-center mb-4">
                <div id="status-loader" class="loader ease-linear rounded-full border-4 border-t-4 border-gray-200 h-10 w-10"></div>
            </div>
            <p id="status-text" class="font-medium text-lg"></p>
        </div>

        <!-- Result Section -->
        <div id="result-section" class="hidden space-y-4 section-transition opacity-0">
            <h2 id="result-title" class="text-xl font-bold text-center"></h2>
            <div class="border rounded-xl overflow-hidden shadow-md">
                <canvas id="result-canvas" class="w-full h-auto"></canvas>
            </div>
             <div id="manual-report-prompt" class="hidden text-center space-y-2">
                <p class="text-gray-600">You can still report this issue manually.</p>
                <button id="manual-report-button" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition-colors">
                    Report Manually
                </button>
            </div>
            <div id="report-status" class="hidden text-center p-3 rounded-lg bg-gray-100">
                 <p id="report-status-text" class="font-medium text-gray-700"></p>
            </div>
        </div>

        <!-- Manual Form Section -->
        <div id="manual-form-section" class="hidden space-y-4 section-transition opacity-0">
             <h2 class="text-xl font-bold text-center">Manual Report</h2>
             <div>
                <label for="problem-description" class="block text-sm font-medium text-gray-700 mb-1">Describe the problem:</label>
                <textarea id="problem-description" rows="4" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500" placeholder="e.g., 'Large pothole in the middle of the lane, causing traffic to swerve.'"></textarea>
             </div>
             <button id="submit-manual-report" class="w-full bg-green-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-green-700 transition-colors">
                Submit Manual Report
            </button>
        </div>

    </div>

    <script>
        // --- CONFIGURATION ---
        const ROBOFLOW_API_KEY = "djY6VSuRnjsR4C3waivR";
        const MODEL_ID = "new-pothole-detection/1";
        const ROBOFLOW_API_URL = `https://detect.roboflow.com/${MODEL_ID}?api_key=${ROBOFLOW_API_KEY}`;
        const OPENCAGE_API_KEY = '2e0018d31b4d415598d575ff48495d84';
        const EMAIL_TO = 'pranavkh2411@gmail.com';
        const CITY_INCHARGE_EMAIL = "info@jaipurmc.org";

        // --- DOM Elements ---
        const locationTitle = document.getElementById('location-title');
        const locationStatus = document.getElementById('location-status');
        const locationLoader = document.getElementById('location-loader');
        const manualLocationToggle = document.getElementById('manual-location-toggle');
        const manualLocationSection = document.getElementById('manual-location-section');
        const manualAddressInput = document.getElementById('manual-address-input');
        const submitManualLocation = document.getElementById('submit-manual-location');
        const dropZone = document.getElementById('drop-zone');
        const imageUploadInput = document.getElementById('image-upload-input');
        const statusDisplay = document.getElementById('status-display');
        const statusText = document.getElementById('status-text');
        const statusLoader = document.getElementById('status-loader');
        const resultSection = document.getElementById('result-section');
        const resultTitle = document.getElementById('result-title');
        const resultCanvas = document.getElementById('result-canvas');
        const reportStatus = document.getElementById('report-status');
        const reportStatusText = document.getElementById('report-status-text');
        const manualReportPrompt = document.getElementById('manual-report-prompt');
        const manualReportButton = document.getElementById('manual-report-button');
        const manualFormSection = document.getElementById('manual-form-section');
        const problemDescription = document.getElementById('problem-description');
        const submitManualReportButton = document.getElementById('submit-manual-report');

        let userLocation = null;
        let userAddress = "Not available";
        let isProcessing = false;
        let isLocationManual = false;
        let originalImageBase64 = null;

        // --- INITIALIZATION ---
        window.addEventListener('load', () => {
            lucide.createIcons();
            getLocation();
        });

        // --- GEOLOCATION & MANUAL LOCATION ---
        function getLocation() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(showPosition, showError);
            } else {
                setLocationStatus("Geolocation not supported", "Cannot get location.", false);
            }
        }

        function showPosition(position) {
            isLocationManual = false;
            userLocation = {
                latitude: position.coords.latitude,
                longitude: position.coords.longitude
            };
            getAddress(userLocation.latitude, userLocation.longitude);
        }

        async function getAddress(lat, lon) {
            try {
                const response = await fetch(`https://api.opencagedata.com/geocode/v1/json?q=${lat}+${lon}&key=${OPENCAGE_API_KEY}`);
                if (!response.ok) throw new Error('Failed to fetch address');
                const data = await response.json();
                if (data.results && data.results.length > 0) {
                    userAddress = data.results[0].formatted;
                    setLocationStatus("Location Found", userAddress, true);
                } else {
                    throw new Error('No address found');
                }
            } catch (error) {
                console.error("Geocoding error:", error);
                userAddress = `Lat: ${lat.toFixed(4)}, Lon: ${lon.toFixed(4)}`;
                setLocationStatus("Location Found", "Could not get street address.", false);
            }
        }

        function showError(error) {
            let message = "Could not get location.";
            if (error.code === error.PERMISSION_DENIED) message = "Location access denied.";
            setLocationStatus(message, "Enable location for accurate reports.", false);
        }

        function setLocationStatus(title, status, success) {
            locationTitle.textContent = title;
            locationStatus.textContent = status;
            locationLoader.style.display = 'none';
            manualLocationToggle.classList.remove('hidden');
            const icon = document.getElementById('location-icon');
            if (icon) {
                icon.classList.remove('text-blue-500');
                icon.classList.add(success ? 'text-green-500' : 'text-red-500');
            }
        }
        
        manualLocationToggle.addEventListener('click', () => {
            manualLocationSection.classList.toggle('hidden');
            manualLocationSection.classList.toggle('opacity-0');
            if (!manualLocationSection.classList.contains('hidden')) {
                manualAddressInput.value = (userAddress && !userAddress.startsWith("Lat:")) ? userAddress : '';
                manualAddressInput.focus();
            }
        });

        submitManualLocation.addEventListener('click', () => {
            const manualAddress = manualAddressInput.value.trim();
            if (manualAddress) {
                userAddress = manualAddress;
                userLocation = null; // Invalidate coordinates
                isLocationManual = true;
                setLocationStatus("Location Updated", `${userAddress} (Manual Entry)`, true);
                manualLocationSection.classList.add('hidden', 'opacity-0');
            } else {
                alert("Please enter an address.");
            }
        });

        // --- FILE HANDLING & UI FLOW ---
        dropZone.addEventListener('click', () => !isProcessing && imageUploadInput.click());
        imageUploadInput.addEventListener('change', (e) => e.target.files[0] && handleFile(e.target.files[0]));
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eName => dropZone.addEventListener(eName, e => {e.preventDefault(); e.stopPropagation();}, false));
        ['dragenter', 'dragover'].forEach(eName => dropZone.addEventListener(eName, () => dropZone.classList.add('drag-over'), false));
        ['dragleave', 'drop'].forEach(eName => dropZone.addEventListener(eName, () => dropZone.classList.remove('drag-over'), false));
        dropZone.addEventListener('drop', (e) => e.dataTransfer.files[0] && handleFile(e.dataTransfer.files[0]), false);
        
        manualReportButton.addEventListener('click', () => {
            resultSection.classList.add('hidden', 'opacity-0');
            manualFormSection.classList.remove('hidden');
            setTimeout(() => manualFormSection.classList.remove('opacity-0'), 10);
        });
        
        submitManualReportButton.addEventListener('click', async () => {
            const description = problemDescription.value.trim();
            if (!description) {
                alert('Please describe the problem.');
                return;
            }
            manualFormSection.classList.add('hidden', 'opacity-0');
            showStatus('Sending manual report...', true);
            await sendEmailReport(0, description);
            showStatus('Manual Report Sent!', false);
        });

        function handleFile(file) {
            if (isProcessing) return;
            if (['image/jpeg', 'image/png', 'image/jpg'].includes(file.type)) {
                processImage(file);
            } else {
                alert("Invalid file type. Please upload a PNG or JPG image.");
            }
        }

        async function processImage(file) {
            isProcessing = true;
            showStatus('Analyzing for potholes...', true);
            resultSection.classList.add('hidden', 'opacity-0');
            manualFormSection.classList.add('hidden', 'opacity-0');
            manualLocationSection.classList.add('hidden', 'opacity-0');

            const reader = new FileReader();
            reader.onload = async (e) => {
                originalImageBase64 = e.target.result;
                const base64Image = originalImageBase64.split(',')[1];
                
                try {
                    const response = await fetch(ROBOFLOW_API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                        body: base64Image
                    });
                    if (!response.ok) throw new Error(`API Error: ${response.statusText}`);
                    const result = await response.json();
                    await displayResult(file, result);

                } catch (error) {
                    console.error("Inference error:", error);
                    showStatus(`Error: ${error.message}`, false);
                } finally {
                    isProcessing = false;
                    imageUploadInput.value = '';
                }
            };
            reader.readAsDataURL(file);
        }

        function showStatus(message, showLoader) {
            statusDisplay.classList.remove('hidden');
            setTimeout(() => statusDisplay.classList.remove('opacity-0'), 10);
            statusText.textContent = message;
            statusLoader.style.display = showLoader ? 'block' : 'none';
             statusDisplay.className = `text-center p-4 rounded-lg section-transition opacity-0 ${
                !showLoader && message.startsWith('Error') ? 'bg-red-100 text-red-800' : 
                !showLoader ? 'bg-green-100 text-green-800' : ''
            }`;
        }
        
        async function displayResult(imageFile, result) {
            statusDisplay.classList.add('hidden', 'opacity-0');
            resultSection.classList.remove('hidden');
            setTimeout(() => resultSection.classList.remove('opacity-0'), 10);
            reportStatus.classList.add('hidden');
            manualReportPrompt.classList.add('hidden');

            const detectedPotholes = result.predictions.filter(p => p.class.toLowerCase() === 'pothole');
            const potholeCount = detectedPotholes.length;

            await drawImageWithBoxes(imageFile, detectedPotholes);

            if (potholeCount > 0) {
                resultTitle.textContent = `Success! ${potholeCount} Pothole(s) Detected.`;
                await sendEmailReport(potholeCount);
            } else {
                resultTitle.textContent = "No potholes were detected.";
                manualReportPrompt.classList.remove('hidden');
            }
        }

        async function sendEmailReport(potholeCount, manualDescription = null) {
            reportStatus.classList.remove('hidden');
            reportStatusText.textContent = 'Sending automatic report...';

            let subject, htmlBody;
            const locationInfo = isLocationManual 
                ? `<p><strong>Address (Manually Entered):</strong> ${userAddress}</p>`
                : `<p><strong>Address:</strong> ${userAddress}</p>
                   <p><strong>Coordinates:</strong> ${userLocation ? `${userLocation.latitude}, ${userLocation.longitude}` : 'N/A'}</p>
                   ${userLocation ? `<p><a href="https://www.google.com/maps?q=${userLocation.latitude},${userLocation.longitude}">View on Google Maps</a></p>` : ''}`;

            if (manualDescription) {
                subject = `MANUAL Pothole Report: ${userAddress}`;
                const imageToSendBase64 = originalImageBase64;
                htmlBody = `
                    <h1>MANUAL Pothole Report</h1>
                    <p>A user has manually reported a road issue at the following location:</p>
                    ${locationInfo}
                    <hr>
                    <h3>User's Description:</h3>
                    <p style="font-style: italic; background-color: #f1f1f1; padding: 10px; border-radius: 5px;">"${manualDescription}"</p>
                    <hr>
                    <h3>User's Uploaded Image:</h3>
                    <img src="${imageToSendBase64}" alt="User uploaded image" style="max-width: 100%; border: 1px solid #ccc;"/>
                `;
            } else {
                subject = `Pothole Report: ${userAddress}`;
                const imageToSendBase64 = resultCanvas.toDataURL('image/jpeg');
                htmlBody = `
                    <h1>Automated Pothole Report</h1>
                    <p><strong>${potholeCount} pothole(s)</strong> were automatically detected at the following location:</p>
                    ${locationInfo}
                    <hr>
                    <h3>Detected Image (with annotations):</h3>
                    <img src="${imageToSendBase64}" alt="Annotated pothole detection" style="max-width: 100%; border: 1px solid #ccc;"/>
                `;
            }
            
            try {
                const response = await fetch('/.netlify/functions/send-email', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        to: [EMAIL_TO, CITY_INCHARGE_EMAIL],
                        subject: subject,
                        html: htmlBody
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Server Error: ${errorData.message}`);
                }
                
                reportStatusText.textContent = '✓ Report Sent Successfully!';
                reportStatus.className = 'text-center p-3 rounded-lg bg-green-100 text-green-800';

            } catch (error) {
                console.error("Email sending error:", error);
                reportStatusText.textContent = `✗ Failed to send report. ${error.message}`;
                reportStatus.className = 'text-center p-3 rounded-lg bg-red-100 text-red-800';
            }
        }

        function drawImageWithBoxes(imageFile, predictions) {
            return new Promise((resolve) => {
                const img = new Image();
                const reader = new FileReader();
                reader.onload = (e) => {
                    img.src = e.target.result;
                    img.onload = () => {
                        const canvas = resultCanvas;
                        const ctx = canvas.getContext('2d');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0);
                        if (predictions.length > 0) {
                            predictions.forEach(pred => {
                                const x = pred.x - pred.width / 2;
                                const y = pred.y - pred.height / 2;
                                ctx.strokeStyle = '#3b82f6';
                                ctx.lineWidth = Math.max(4, img.width * 0.005);
                                ctx.strokeRect(x, y, pred.width, pred.height);
                                const label = `${pred.class} (${(pred.confidence * 100).toFixed(0)}%)`;
                                ctx.font = `bold ${Math.max(16, img.width * 0.02)}px Inter`;
                                const textWidth = ctx.measureText(label).width;
                                const textHeight = Math.max(24, img.width * 0.03);
                                ctx.fillStyle = '#3b82f6';
                                ctx.fillRect(x, y - textHeight, textWidth + 10, textHeight);
                                ctx.fillStyle = '#ffffff';
                                ctx.fillText(label, x + 5, y - (textHeight * 0.2));
                            });
                        }
                        resolve();
                    }
                }
                reader.readAsDataURL(imageFile);
            });
        }
    </script>
</body>
</html>